import os
import pandas as pd
import matplotlib.pyplot as plt
import numpy as np
#import scipy.optimize as spo #Need to properly install scipy library
import time

#From util import get_data, plot_data

def test_run():
	print('End')

#####################################
# Building a dataframe to work with #
#####################################
def time_based_data_frame():
	dates = pd.date_range('2010-01-01', '2017-01-01')

	df1 = pd.DataFrame(index=dates) #Creating empty data frame

	symbols = ['SPY','INTC','IBM'] #Read in more stocks
	for symbol in symbols:
		df_temp = pd.read_csv("Data_Holder/{}.csv".format(symbol), index_col='Date', parse_dates=True,
						 	  usecols=['Date','Adj Close'], na_values=['NaN']) #Read in every stock by symbol
		df_temp = df_temp.rename(index = str, columns={'Adj Close':symbol}) #rename to prevent clash
		df1 = df1.join(df_temp) #use default how='left'

	df1 = df1.dropna() #drop the NaN Strings (na_values) from the table
	print(df1)

############################
# Handling Incomplete Data #
############################
def fill_data(df):
	"""Fills in missing data holding the previous value for forward filling, 
		fills in first value if no value is known before"""
	df.fillna(method = 'ffill', inplace=True) #Always forwad fill first
	df.fillna(method = 'bfill', inplace=True) #Back fill second

######################################
# Create Histogram and Scatter Plots #
######################################
def get_histogram(df):
	"""Creates a histogram of the daily returns of a stock"""
	dates = pd.date_range('2000-01-01', '2017-01-01') #Read Data
	symbols = ['SPY']
	df = get_data(symbols, dates)

	daily_returns = compute_daily_returns(df) #Get daily return

	daily_returns.hist(bins=20) #Plot a histogram

	#Get Mean and standard deviations of the histogram plot of daily returns
	mean = daily_returns['SPY'].mean()
	print("Mean = ", mean)
	std = daily_returns['SPY'].std()
	print("Standard Deviation = ", std)
	plt.axvline(x=mean, color='y', linestyle='--')
	plt.axvline(x=std, color='r', linestyle='solid')
	plt.axvline(x=-std, color='r', linestyle='solid')
	plt.show()

def get_multiple_histograms():
	"""To compare multiple histograms to one another"""
	dates = pd.date_range('2000-01-01', '2017-01-01') #Read Data
	symbols = ['SPY', 'INTC', 'IBM']
	df = get_data(symbols, dates)
	plot_data(df)

	daily_returns = compute_daily_returns(df) #Get daily return

	daily_returns['SPY'].hist(bins=20, label="SPY") #Plot a histogram
	daily_returns['INTC'].hist(bins=20, label="INTC") #Plot a histogram
	daily_returns['IBM'].hist(bins=20, label="IBM") #Plot a histogram
	plt.legend(loc='upper right')
	plt.show()

def get_scatter_plot():
	"""To plot daily returns in a scatter plot format and then create a best fit line"""
	dates = pd.date_range('2000-01-01', '2017-01-01') #Read Data
	symbols = ['SPY', 'INTC']
	df = get_data(symbols, dates)
	plot_data(df)

	daily_returns = compute_daily_returns(df) #Get daily return

	daily_returns.plot(kind='scatter', x='SPY', y='INTC') #Scatter plot of SPY and INC
	beta_INTC, alpha_INTC = np.polyfit(daily_returns['SPY'], daily_returns['INTC'], 1) #Creating best fit line
	plt.plot(daily_returns['SPY'], beta_INTC*daily_returns['SPY'] + alpha_INTC, '-', color='r') #plot best fit line
	plt.show()

	#Beta value corrisponds to the relativeness between the two stocks. 
	#The Alpha value correlates which stock performs better (when compared to market)

	daily_returns.plot(kind='scatter', x='SPY', y='IBM') #Scatter plot of SPY and IBM
	beta_IBM, alpha_IBM = np.polyfit(daily_returns['SPY'], daily_returns['IBM'], 1) #Creating best fit line
	plt.plot(daily_returns['SPY'], beta_IBM*daily_returns['SPY'] + alpha_IBM, '-', color='r') #plot best fit line
	plt.show()

	print(daily_returns.corr(method='pearson')) #Calculate the correlation coefficient

################
# Sharpe Ratio #
################
def get_sharpe_ratio():
	"""As Volatility (Risk) increases vs rate of return, the Sharpe decreases"""
	dates = pd.date_range('2000-01-01', '2017-01-01') #Read Data
	symbols = ['SPY']
	df = get_data(symbols, dates)

	daily_returns = compute_daily_returns(df) #Get daily return

	mean = daily_returns['SPY'].mean()
	std = daily_returns['SPY'].std()

	#daily_rf = sqrt(1+0.1)^252 - 1 #getting daily risk free rate (Usually 0)
	
	#k = sqrt(252) #k = constant that is the square root of the number of samples per year (daily)
	#k = sqrt(52) #Weekly
	#k = sqrt(12) #monthly
	#k = 1 = sqrt(1)  #Anually (Just showing formula)
	
	#SR = k* ((mean - daily_rf['SPY'].mean())/(std) #Calculating the Sharpe Ratio

	"""From here on out we should focus on for portfolio:
	1) Cumulative Return
	2) Average daily return
	3) Standard Deviation of Risk
	4) Sharpe Ratio 
	Review this section and build it out of the functions in this document"""

######################
# Optimization Tools #
######################
def func(X):
	"""Given a scalar X, return some value (a real number)."""
	Y = (X - 1.5)**2 + 0.5 #** is squared
	print("X = {}, Y = {}".format(X, Y)) #for tracing
	return Y

def get_minimum_func_value():
	"""Find the minimum value of the function"""
	Xguess = 2.0 #require an initialization guess
	min_result = spo.minimize(func, Xguess, method='SLSQP', options={'disp':True})
	print("Minima found at:")
	print("X = {}, Y = {}".format(min_result.x, min_result.fun))

def error(line, data): #error function
	"""Compute error between given line model and observed data.
		Parameters:
		-----------
		line: tuple/list/array (C0, C1) where C0 is slope and C1 is Y-intercept
		data: 2D array where each row is a point (x, y)

		Returns error as a single real value."""

		#Metric: Sum of squared Y-axis differences
	err = np.sum((data[:, 1] - (line[0] * data[:, 0] + line[1])) ** 2)
	return err

def get_original_line():
	l_orig = np.float32([4, 2])
	print("Original line: C0 = {}, C1 = {}".format(l_orig[0], l_orig[1]))
	Xorig = np.linspace(0, 10, 21)
	Yorig = l_orig[0] * Xorig + l_orig[1]
	plt.plot(Xorig, Yorig, 'b--', linewidth = 2.0, label = "Original Line")

def get_noisy_data():
	"""Generate noisy data points"""
	noise_sigma = 3.0
	noise = np.random.normal(0, noise_sigma, Yorig.shape)
	data = np.asarray([Xorig, Yorig + noise]).T 
	plt.plot(data[:,0], data[:,1], 'go', label="Data Points")

def fit_line(data, error_func):
	"""Fit a line to given data, using a supplied error function.
		Parameters:
		-----------
		data: 2D array where each row is a point (X0, Y)
		error_func: function that computes the error between a line and observed data

		Returns line that minimizes the error function."""
	#Generate initial guess for line model
	l = np.float32([0, np.mean(data[:, 1])]) #slope = 0, intercept = mean (Y values)

	#Plot initial guess (optional)
	x_ends = np.float32([-5, 5])
	plt.plot(x_ends, l[0] * x_ends + l[1], 'm--', linewidth = 2.0, label = "Initial Guess")

	#Call optimizer to minimize error function
	result = spo.minimize(error_func, l, args=(data,), method='SLSQP', options = {'display'})
	return result.x

def get_best_fit_line():
	l_fit = fit_line(data, error)
	print("Fitted line: C0 = {}, C1 = {}".format(l_fit[0], l_fit[1]))
	plt.plot(data[:, 0], l_fit[0] * data[:, 0] + l_fit[1], 'r--', linewidth=2.0)

def error_poly(C, data):
	"""Compute error between given polynomial and observed data.
		
		Parameters
		----------
		C: numpy.poly1d object or equivalent array representing polynomial coefficients
		data: 2D array where each row is a point (x, y)

		Returns error as a single real value."""
	#Metric: Sum of squared Y-axis differences
	err = np.sum((data[:, 1] - np.polyval(C, data[:, 0]))**2)
	return err

def fit_poly(data, error_func, degree=3):
	"""Fit a polynomial to given data, using supplied error function.
		Parameters
		----------
		data: 2D array where each row is a point (x, y)
		error_func: function that computes the error between a polynomial and observed data

		Returns plynomial that minimizes the error function."""

	#Generate initial guess for polynomial model (all coeffs = 1)
	Cguess = np.poly1d(np.ones(degree + 1, dtype=np.float32))

	#Plot initial guess (optional)
	x = np.linspace(-5, 5, 21)
	pltplot(x, np.polyval(Cguess, x), 'm--', linewidth=2.0, lable='Initial Guess')

	#Call optimizer to minimize error function
	result = spo.minimize(error_func, Cguess, args=(data,), method= 'SLSQP', options = {'display'})
	return np.poly1d(result.x) #convert optimal result into a poly1d object and return

##########################
# Portfolio Optimization #
##########################
	#Solve for Cumulative return
	#Solve for minimum volatility
	#Solve for Sharpe Ratio

	"""Share Ratio:
		Frame the problem:
		-Provide a function to minimize f(x) = sharpe ratio * (-1) ...looking for largest sharpe ratio
		-Provide an initial guess for X
		-Call the optimizer"""

	"""Ranges and Constraints:
		Ranges:
			Limits on values for X 0->1
		Constraints: Properties of X that must be "True"
			Sum of absolute values of X = 100%  #Refer to the assignment text
	"""

#################
# Utility Tools #
#################
def symbol_to_path(symbol, base_dir="Data_Holder"):
	"""Return CSV file path given ticker symbol."""
	return os.path.join(base_dir, "{}.csv".format(str(symbol)))

def get_data(symbols, dates):
	"""Read stock data (adjusted close) for given symbols from csv files"""
	df = pd.DataFrame(index=dates)
	if 'SPY' not in symbols: #add SPY for reference, if absent
		symbols.insert(0, 'SPY')

	symbols = ['INTC','IBM','SPY'] #Read in more stocks
	for symbol in symbols:
		df_temp = pd.read_csv(symbol_to_path(symbol), index_col='Date', parse_dates=True,
						 	  usecols=['Date','Adj Close'], na_values=['NaN']) #Read in every stock by symbol
		df_temp = df_temp.rename(index = str, columns={"Adj Close": symbol}) #rename to prevent clash
		df = df.join(df_temp) #use default how='left'
		if symbol == 'SPY': #drop dates SPY did not trade
			df = df.dropna()
	return df

def plot_data(df, title="Stock Prices"):
	"""Plot stock prices"""
	ax = df.plot(title=title, fontsize=10)
	ax.set_xlabel("Date")
	ax.set_ylabel("Price ($USD)")
	plt.show()

def plot_selected(df, columns, start_index, end_index):
	"""PLot the desired columns over index values in the given range."""
	plot_data(df.ix[start_index:end_index, columns],title="Selected Data")

def normalize_data(df):
	"""Normalize stock prices using the first row of the dataframe."""
	return df/df.ix[0,:]

### Using Time Function
def time_tracker(func, *args):
	"""Execute function with given arguments, and measure execution time."""
	t0 = time()
	result = func(*args) #all arguments are passed in as-is
	t1 = time()
	return result, t1 - t0

def get_max_index(a):
	"""Return the index of the maximum value in given 1D array"""
	return a.argmax()

def manual_mean(arr):
	"""Compute mean (average) of all elements in the given 2D array"""
	sum = 0
	for i in xrange(0, arr.shape[0]):
		for j in xrange(0, arr.shape[1]):
			sum = sum + arr[i, j]
	return sum/arr.size		

def numpy_mean(arr):
	"""Compute mean (average) using NumPy"""
	return arr.mean()

def compute_global_statistics():
	"""Compute various functions on the data (on each column)"""
	print(df.mean())
	print(df.median())
	print(df.std())

def rolling_statistics():
	"""Compute a moving window of various functions along the stock (moving average)"""
	#Data setup
	dates = pd.date_range('2010-01-01', '2017-01-01')
	symbols = ['SPY','INTC','IBM']
	df = get_data(symbols, dates)

	#Rolling Mean
	ax = df['SPY'].plot(title="SPY Rolling Mean", label='SPY') #Plot PSY data, retain matplotlib axis object
	rm_SPY = df['SPY'].rolling(window = 20).mean() #Compute rolling mean using a 20-day window

	rm_SPY.plot(label='Rolling Mean', ax=ax) #Add rolling mean to same plot

	ax.set_xlabel("Date") #Add axis labels and legend
	ax.set_ylabel("Price")
	ax.legend(loc='upper left')
	plt.show()

def bollinger_bands():
	"""Compute Bollinger Bands (Standard Deviatation of +/-2)"""
	#Data Setup
	dates = pd.date_range('2015-01-01', '2017-01-01')
	symbols = ['SPY','INTC','IBM']
	df = get_data(symbols, dates)

	#Compute rolling mean
	rm_SPY = get_rolling_mean(df['SPY'], window=30)

	#Compute rolling standard deviation
	rstd_SPY = get_rolling_std(df['SPY'], window=30)

	#Compute upper and lower bands
	upper_band, lower_band = get_bollinger_bands(rm_SPY, rstd_SPY)

	#Plotting:
	ax = df['SPY'].plot(title="Bollinger Bands", label='SPY') #Plot raw SPY values
	rm_SPY.plot(label='Rolling Mean', ax=ax)	#plot Rolling Mean
	upper_band.plot(label='Upper Band', ax=ax)	#plot Bollinger band (upper)
	lower_band.plot(label='Lower Band', ax=ax) #plot Bollinger band (lower)

	ax.set_xlabel("Date") #Add Axis labels and legend
	ax.set_ylabel("Price")
	ax.legend(loc='upper left')
	plt.show()


###########################
# Data Manipulation Tools #
###########################
def get_max_close(symbol):
	"""Return the maximum closing value for stock indicated by symbol.
	Note: Data for a stock is stored in file: Data_Holder/INTC.csv"""
	df = pd.read_csv("Data_Holder/INTC.csv".format(symbol))
	return df['Close'].max()

def get_mean_volume(symbol):
	"""Return the mean volume of the given stock indicated by symbol.
	Note: Data for a stock is stored in file: Data_Holder/INTC.csv"""
	df = pd.read_csv("Data_Holder/INTC.csv".format(symbol))
	return df['Volume'].mean()

def get_plot(symbol):
	df = pd.read_csv("Data_Holder/INTC.csv")
	#print(df['Close','Adj Close'])
	df[['Close','Adj Close']].plot()
	plt.show() #must be called to show plots

def plot_highs(symbol):
	df = pd.read_csv("Data_Holder/INTC.csv")
	print(df['High'])
	df['High'].plot()
	plt.show() #must be called to show plots

def slice_row(): #fill in function requirements
	"""Slice by row range (dates) using DataFrame.ix[] selector"""
	print(df.ix['2010-01-01':'2010-12-31'])#The year 2010

def slice_column(): #fill in function requirments
	"""Slice by row range (symbols)"""
	print(df['SPY','INTC'])

def slice_horizontal_and_vertical(): #fill in function requirements
	"""Slice by row and column"""
	print(df.ix['2010-01-01':'2010-12-31', ['SPY','IBM']])

### Arrays
def one_dimensional_array():
	#List of tuple to 1D array
	print(np.array([2,3,4]))

def two_dimensional_array():
	#List of tuple to 2D array
	print(np.array([(2,3,4), (5,6,7)]))

def empty_array():
	#Create an Empty 3D array
	print(np.empty((5,4,3)))

def ones_array():
	#Create an array of 1's that is not floating point (dtype)
	print(np.ones((5,4), dtype=np.int))
	#creat an array of 0's that is not floating point (dtype)
	print(np.zeros((6,9), dtype=np.int))

def random_array():
	#Generate an array full of random numbers, uniformly sampled from [0.0, 1.0)
	print(np.random.random((5,4))) #pass in size of a tuple
	print(np.random.rand(5,4)) #function arguments (not a tuple)

	#Generate an array from a Gaussian (normal) distribution
	print(np.random.normal(size=(2,3))) #standard normal (mean = 0, s.d = 1)
	print(np.random.normal(50,10, size=(2,3))) #change mean to 50 and standard deviation to 10

	#Generate random integers
	print(np.random.randint(10)) #a single integer in [0,10)
	print(np.random.randint(0, 10)) #same as above, but specifying [low, high) explicit
	print(np.random.randint(0, 10, size=5)) #random integers as a 1D array
	print(np.random.randint(0, 10, size=(2,3))) # 2x3 arra of random integers

def shape_of_array():
	a = np.random.random((5, 4)) #5x4 array of random numbers
	print(a)
	print(a.shape) #Prints out the dimensions (shape) of the array
	print(a.shape[0]) #number of rows
	print(a.shape[1]) #number of columns
	print(len(a.shape)) #prints out the number of places (length) in the array (currently 1 for row and 1 for column)
	print(a.size) #prints the number of elements in the array (5x4 = 20)
	print(a.dtype) #checks the data type of the array

def operations_on_arrays():
	np.random.seed(693) #seed the random number generator (to get the same random numbers)
	a = np.random.randint(0, 10, size=(5, 4)) #5x4 random integers in [0, 10)
	print("Array:\n", a)

	#Sum of all elements
	print("Sum of all elements:", a.sum())

	#Iterate over rows, to compute sum of each column
	print("Sum of each column:\n", a.sum(axis=0))
	#Iterate over columns to compute sum of each row
	print("Sum of each row:\n", a.sum(axis=1))

	#StatisticsL: min, max, mean (across rows, cols, and overall)
	print("Minimum of each column:\n", a.min(axis=0))
	print("Maximum of each row:\n", a.max(axis=1))
	print("Mean of all elements:", a.mean()) #leave out the axis argument to span the entire array

def access_array_element():
	a = np.random.rand(5,4)
	print("Array:\n", a)

	#Accessing element at position (3,2)
	element = a[3,2]
	print(element)

	#Accessing elements in a defined range
	print(a[0, 1:3]) #accessing the first row, column 1 -> 3 (but not including 3)
	#Top-left corner
	print(a[0:2, 0:2])
	#Slicing: n:m:t specifies a range that starts at n, stops before m, in steps of size t
	print(a[:, 0:3:2]) #will select columns 0, 2 for every row

def assign_value_to_array_location():
	"""Assigning a value to a particular location"""
	a[0,0] = 1
	print("\nModified (replaced one element):\n", a)

	#Assignging a list of values to a column in an array
	a[:, 3] = [1, 2, 3, 4, 5]
	print("\nModified(replaced a column with a list):\n", a)


def list_of_indices():
	"""Accessing using a list of indices"""
	a = np.random.rand(5) #setting up the array

	indices = np.array([1,1,2,3])
	print(a[indices])

def index_boolean_array():
	"""indexing a boolean (True/False) array"""
	a = np.array([(20, 25, 10, 23, 26, 32, 10, 5, 0),(0,2,50,20,0,1,28,5,0)])
	print(a)

	#calculating the mean
	mean = a.mean()
	print(mean)
	#using numPy masking to get all values lower than the mean
	print(a[a<mean])
	#replace all values lower than the mean with the mean in the array
	a[a<mean] = mean
	print(a)

def arithmetic_on_array():
	"""General array arithmetic operations"""
	a = np.array([(1,2,3,4,5),(10,20,30,40,50)])
	print("origional array a:\n", a)
	b = np.array([(100, 200, 300, 400, 500), (1,2,3,4,5)])
	print("\nOriginal array b:\n", b)

	#Multiply "a" by 2
	print("\nMulitply 'a' by 2:\n", 2*a)
	#Divide "a" by 2
	print("\nDivide 'a' by 2:\n", a/2)
	#Add array "a" and "b"
	print("\nAdd 'a' + 'b':\n", a+b)
	#Mulitple "a" and "b" (element to element)
	print("\nMultiply 'a' and 'b':\n", a*b)
	#Divide "a" by "b"
	print("\nDivide 'a' by 'b':\n", a/b)

def get_rolling_mean(values, window):
	"""Return rolling mean of given values, using specified window size."""
	#return pd.values.rolling(window = window).mean()
	return pd.rolling_mean(values, window = window) #there may be a new way to do this soon in Pandas

def get_rolling_std(values, window):
	"""Return rollinw standard deviation of given values, using specified window size."""
	#return pd.values.rolling(window = window).std()
	return pd.rolling_std(values, window = window)

def get_bollinger_bands(rm, rstd):
	"""Return upper and lower Bollinger Bands. (2x standard deviation)"""
	upper_band = rm + rstd*2
	lower_band = rm-rstd*2
	return upper_band, lower_band

def get_daily_returns():
	"""Calculate the Daily Returns (%) of a stock and compare"""
	dates = pd.date_range('2010-01-01', '2012-01-01')
	symbols = ['SPY','INTC','IBM']
	df = get_data(symbols, dates)
	plot_data(df)

	daily_returns = compute_daily_returns(df) #Compute Daily Returns
	plot_data(daily_returns, title="Daily Returns", set_ylabel="Daily Returns")

def compute_daily_returns(df):
	"""Compute and return the daily return values."""
	#Note: returned DataFrame must have the same number of rows
	daily_returns = df.copy() #copy given DataFrame to match size and column names
	daily_returns[1:] = (df[1:]/df[:-1].values) - 1
	daily_returns.ix[0, :] = 0 #set daily returns for row 0 to 0
	return daily_returns

def compute_daily_returns_pandas(df):
	"""Compute and retrn the daily return values using pandas"""
	daily_returns = (df / df.shift(1)) - 1 #Easier using pandas
	return daily_returns

def compute_cumulative_returns(df):
	"""Compute the cumulative return of a stock"""
	cumulative_returns = (df/df.ix[0,:]) - 1
	return cumulative_returns

if __name__ == "__main__":
	test_run()